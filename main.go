package main

import (
	"bufio"
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
)

var Version = "1.0.0"

const Sep = string(filepath.Separator)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("version: ", Version)
		fmt.Printf("usage: %s [filename]\n", os.Args[0])
		return
	}
	fn, err := filepath.Abs(os.Args[1])
	if err != nil {
		return
	}
	if filepath.Base(fn) != "service.go" {
		return
	}
	content, err := genFromFile(fn)
	if err != nil {
		log.Fatalln(err)
	}
	if content != nil {
		outFn := filepath.Dir(fn) + "/exported.go"
		_ = os.WriteFile(outFn, content, 0644)
		err := exec.Command("go", "fmt", outFn).Run()
		if err != nil {
			log.Fatalln(err)
		}
	}
}

func genFromFile(fn string) (content []byte, err error) {
	f, err := os.Open(fn)
	if err != nil {
		return
	}
	defer f.Close()
	rd := bufio.NewReader(f)
	var buf bytes.Buffer
	buf.WriteString("// Code generated by service-export(" + Version + "). DO NOT EDIT.\n")
	buf.WriteString("// source: " + filepath.Base(fn) + "\n\n")
	var (
		isValid     bool
		packageName string
	)
	for {
		line, _, err := rd.ReadLine()
		if err == io.EOF {
			break
		}
		switch {
		case len(line) == 0:
			buf.WriteByte('\n')
		case bytes.HasPrefix(line, []byte("package ")):
			packageName = strings.Split(string(line), " ")[1]
			buf.Write(line)
			buf.WriteByte('\n')
		case bytes.Equal(line, []byte("import (")):
			buf.Write(line)
			buf.WriteByte('\n')
			for {
				line2, _, _ := rd.ReadLine()
				buf.Write(line2)
				buf.WriteByte('\n')
				if bytes.Equal(line2, []byte(")")) {
					break
				}
			}
		case bytes.HasPrefix(line, []byte("import ")):
			buf.Write(line)
			buf.WriteByte('\n')
		case bytes.Equal(line, []byte("type Service interface {")):
			isValid = true
			buf.WriteString(`var defaultService Service

func Register(s Service) {
	defaultService = s
}

`)
			for {
				line2, _, _ := rd.ReadLine()
				line2 = bytes.TrimSpace(line2)
				if len(line2) == 0 {
					continue
				}
				if bytes.Equal(line2, []byte("}")) {
					break
				}
				if line2[len(line2)-1] == '(' {
					line2 = append(line2, '\n')
					for {
						tmp, _, _ := rd.ReadLine()
						line2 = append(line2, tmp...)
						line2 = append(line2, '\n')
						if len(tmp) > 0 && tmp[len(tmp)-1] == ')' {
							break
						}
					}
				}
				if bytes.HasPrefix(line2, []byte("//")) {
					buf.Write(line2)
					buf.WriteByte('\n')
				} else {
					ss := strings.SplitN(string(line2), "(", 2)
					fName := ss[0]
					params := strings.Split(ss[1], ")")[0]
					var vars string
					for _, param := range strings.Split(params, ",") {
						v := strings.Split(strings.TrimSpace(param), " ")[0]
						if strings.Contains(param, "...") {
							vars += v + "..., "
						} else {
							vars += v + ", "
						}
					}
					vars = vars[0 : len(vars)-2]
					// 解析返回值列表
					var retTypes []string
					rets := strings.Trim(strings.TrimSpace(strings.SplitN(ss[1], ")", 2)[1]), "()") // 不考虑参数包含括号的情况
					for _, v := range strings.Split(rets, ",") {
						v = strings.TrimSpace(v)
						if v != "" {
							if strings.Contains(v, " ") {
								retTypes = append(retTypes, strings.TrimSpace(strings.SplitN(v, " ", 2)[1]))
							} else {
								retTypes = append(retTypes, v)
							}
						}
					}
					buf.WriteString("func ")
					buf.Write(line2)
					buf.WriteString(" {\n")
					buf.WriteString("\tif defaultService == nil {\n")
					buf.WriteString(fmt.Sprintf("\t\tpanic(\"调用模块方法: %s.%s 失败，服务未注册\")\n", packageName, fName))
					buf.WriteString("\t}\n")
					if len(retTypes) == 0 { // 没有返回值
						buf.WriteString(fmt.Sprintf("\tdefaultService.%s(%s)\n", fName, vars))
					} else if retTypes[len(retTypes)-1] == "error" { // 最后一个返回值是error类型，如果非nil，trace error
						retVars := ""
						for n := 1; n <= len(retTypes); n++ {
							retVars += fmt.Sprintf("v%d,", n)
						}
						retVars = retVars[0 : len(retVars)-1]
						buf.WriteString(fmt.Sprintf("\t%s := defaultService.%s(%s)\n", retVars, fName, vars))
						buf.WriteString(fmt.Sprintf("\treturn %s\n", retVars))
					} else {
						buf.WriteString(fmt.Sprintf("\treturn defaultService.%s(%s)\n", fName, vars))
					}
					buf.WriteString("}\n\n")
				}
			}
		}
	}
	if isValid {
		return buf.Bytes(), nil
	}
	return
}

// Module contains the relative data of go module,
// which is the result of the command go list
type Module struct {
	Path      string
	Main      bool
	Dir       string
	GoMod     string
	GoVersion string
}

// 通过命令`go list -json -m`判断workDir
func getModule(workDir string) (*Module, error) {
	if workDir == "" {
		return nil, errors.New("目录不能为空")
	}
	cmd := exec.Command("go", "list", "-json", "-m")
	cmd.Dir = workDir
	data, err := cmd.Output()
	if err != nil {
		return nil, err
	}
	var m Module
	return &m, json.Unmarshal([]byte(data), &m)
}
